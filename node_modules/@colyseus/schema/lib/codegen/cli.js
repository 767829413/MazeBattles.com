"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var path = require("path");
var argv_1 = require("./argv");
var parser_1 = require("./parser");
function displayHelp() {
    console.log("\nschema-codegen [path/to/Schema.ts]\n\nUsage (C#/Unity)\n    schema-codegen src/Schema.ts --output client-side/ --cs --namespace MyGame.Schema\n\nValid options:\n    --output: fhe output directory for generated client-side schema files\n    --cs: generate files C#/Unity\n    --cpp: generate files C++\n    --hx: generate files for Haxe\n\nOptional:\n    --namespace: generate namespace on output code");
    process.exit();
}
var args = argv_1.default(process.argv.slice(2));
if (args.help) {
    displayHelp();
}
var generatorId;
if (args.cs) {
    generatorId = 'cs';
}
else if (args.hx) {
    generatorId = 'hx';
}
else if (args.cpp) {
    generatorId = 'cpp';
}
if (!args.output || !fs.existsSync(args.output)) {
    console.error("You must provide a valid (and existing) --output directory.");
    displayHelp();
}
var generator = require('./' + generatorId).generate;
if (!generator) {
    console.error("You must provide a valid generator as argument.");
}
var classes = parser_1.parseFiles(args._);
var files = generator(classes, args);
files.forEach(function (file) {
    var outputPath = path.resolve(args.output, file.name);
    fs.writeFileSync(outputPath, file.content);
    console.log("generated:", file.name);
});
