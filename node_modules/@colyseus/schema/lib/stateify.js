"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var fs_1 = require("fs");
var Property = /** @class */ (function () {
    function Property() {
    }
    return Property;
}());
var Class = /** @class */ (function () {
    function Class() {
        this.properties = [];
    }
    return Class;
}());
var classes = [];
var currentClass;
var currentProperty;
function inspectNode(node) {
    switch (node.kind) {
        case ts.SyntaxKind.ClassDeclaration:
            currentClass = new Class();
            classes.push(currentClass);
            break;
        case ts.SyntaxKind.PropertyDeclaration:
            break;
        case ts.SyntaxKind.Identifier:
            // console.log("NODE =>", node.getText());
            if (node.getText() === "type" && node.parent.kind !== ts.SyntaxKind.ImportSpecifier) {
                console.log("TYPE DECORATORS:", node.parent.parent.parent.decorators[0].getText());
            }
            if (node.parent.kind === ts.SyntaxKind.ClassDeclaration) {
                currentClass.name = node.getText();
            }
            else if (node.parent.kind === ts.SyntaxKind.PropertyDeclaration) {
                currentProperty = new Property();
                currentProperty.name = node.getText();
                currentClass.properties.push(currentProperty);
            }
            break;
        case ts.SyntaxKind.NumberKeyword:
        case ts.SyntaxKind.StringKeyword:
            currentProperty.type = node.getText();
            break;
    }
    ts.forEachChild(node, inspectNode);
}
var fileNames = process.argv.slice(2);
fileNames.forEach(function (fileName) {
    var sourceFile = ts.createSourceFile(fileName, fs_1.readFileSync(fileName).toString(), ts.ScriptTarget.ES2018, true);
    inspectNode(sourceFile);
});
classes.forEach(function (klass) {
    console.log(">>", klass.name);
    klass.properties.forEach(function (prop) { return console.log("-", prop.name, prop.type); });
    console.log("");
});
